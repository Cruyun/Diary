## 如何实现一个子元素居中，另一个子元素在末尾（上下左右）？

```
------------------
       ABCD      E
------------------
```


### 先行知识：auto margins & flexbox

## 1. How does margin auto work?

我们经常使用`margin: 0 auto;`使一个不固定长宽的元素居中，那么 auto margin 是如何起作用的呢？



If the display of your parent container is flex, then yes, `margin: auto auto` (also known as `margin: auto`) will work to center it both horizontally and vertically, regardless if it is an inline or  block element.

```
#parent {
    width: 50vw;
    height: 50vh;
    background-color: gray;
    display: flex;
}
#child {
    margin: auto auto;
}
<div id="parent">
    <div id="child">hello world</div>
</div>
```







----

主要有以下方法：

- CSS Positioning
- Flexbox with Invisible DOM Element
- Flexbox with Invisible Pseudo-Element
- Flexbox with flex: 1
- CSS Grid Layout


## Method #1: CSS Positioning Properties

Apply position: relative to the flex container.

Apply position: absolute to item D.

Now this item is absolutely positioned within the flex container.

More specifically, item D is removed from the document flow but stays within the bounds of the nearest positioned ancestor.

Use the CSS offset properties top and right to move this element into position.

```
li:last-child {
  position: absolute;
  top: 0;
  right: 0;
  background: #ddd;
}
ul {
  position: relative;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
li {
  display: flex;
  margin: 1px;
  padding: 5px;
  background: #aaa;
}
p {
  text-align: center;
  margin-top: 0;
}
span {
  background-color: aqua;
}

<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
  <li>D</li>
</ul>
<p><span>true center</span></p>
```

## Method #2: Flex Auto Margins & Invisible Flex Item (DOM element)

> Flexible Box Layout Module - 8.1. Aligning with auto margins
> 
> Auto margins on flex items have an effect very similar to auto margins in block flow:
>
> - During calculations of flex bases and flexible lengths, auto margins are treated as 0.
>
> - Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.


With a combination of auto margins and a new, invisible flex item the layout can be achieved.

The new flex item is identical to item D and is placed at the opposite end (the left edge).

More specifically, because flex alignment is based on the distribution of free space, the new item is a necessary counterbalance to keep the three middle boxes horizontally centered. The new item must be the same width as the existing D item, or the middle boxes won't be precisely centered.

The new item is removed from view with visibility: hidden.

In short:

- Create a duplicate of the D element.
- Place it at the beginning of the list.
- Use flex auto margins to keep A, B and C centered, with both D elements 
- creating equal balance from both ends.
- Apply visibility: hidden to the duplicate D

```
li:first-child {
  margin-right: auto;
  visibility: hidden;
}
li:last-child {
  margin-left: auto;
  background: #ddd;
}
ul {
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
li {
  display: flex;
  margin: 1px;
  padding: 5px;
  background: #aaa;
}
p { text-align: center; margin-top: 0; }
span { background-color: aqua; }
<ul>
  <li>D</li><!-- new; invisible spacer item -->
  <li>A</li>
  <li>B</li>
  <li>C</li>
  <li>D</li>
</ul>
<p><span>true center</span></p>
```

With auto margins, flex items can be centered, spaced away or packed into sub-groups.

Unlike justify-content, which is applied to the flex container, auto margins go on flex items.

They work by consuming all free space in the specified direction.

## Method #3: Flex Auto Margins & Invisible Flex Item (pseudo-element)

This method is similar to #2, except it's cleaner semantically and the width of D must be known.

- Create a pseudo-element with the same width as D.
- Place it at the start of the container with ::before.
- Use flex auto margins to keep A, B and C perfectly centered, with the  pseudo and D elements creating equal balance from both ends.


```
ul::before {
  content:"D";
  margin: 1px auto 1px 1px;
  visibility: hidden;
  padding: 5px;
  background: #ddd;
}
li:last-child {
  margin-left: auto;
  background: #ddd;
}
ul {
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
li {
  display: flex;
  margin: 1px;
  padding: 5px;
  background: #aaa;
}
p { text-align: center; margin-top: 0; }
span { background-color: aqua; }


<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
  <li>D</li>
</ul>

```

## Method #4: Add flex: 1 to left and right items

```
/* CSS */
.parent {
  padding: 5px;
  border: 2px solid #000;
}
.left,
.right {
  padding: 3px;
  border: 2px solid red;
}
.center {
  margin: 0 3px;
  padding: 3px;
  border: 2px solid blue;
}

/* HTML */
<div class="parent">
  <div class="left">Left</div>
  <div class="center">Center</div>
  <div class="right"></div>
</div>
```

该方法只适用于**按行排列**的情况。

左右两边的子元素获得相同的宽度（它们将均匀分配可用空间）使得中心元素将始终完美居中。

你不必将左内容复制到右边并隐藏它以获得双方相同的宽度。

## Method #5: CSS Grid Layout
This may be the cleanest and most efficient method. There is no need for absolute positioning, fake elements or other hackery.

Simply create a grid with multiple columns. Then position your items in the middle and end columns. Basically, just leave the first column empty.

```
ul {
  display: grid;
  grid-template-columns: 1fr repeat(3, auto) 1fr;
  grid-column-gap: 5px;
  justify-items: center;
}

li:nth-child(1) { grid-column-start: 2; }
li:nth-child(4) { margin-left: auto; }

/* for demo only */
ul { padding: 0; margin: 0; list-style: none; }
li { padding: 5px; background: #aaa; }
p  { text-align: center; }
<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
  <li>D</li>
</ul>
<p><span>| true center |</span></p>
```

## Method #6: Justify-content: Space-between & Invisible Flex Item (pseudo-element)


```
.parent {
  align-items: center;
  border: 1px solid black;
  display: flex;
  justify-content: space-between;
  margin: 0 auto;
  width: 500px;
}
.right {
    opacity: 0;
}
<div class="parent">
  <span class="left">Left</span>
  <span class="center">Center</span>
  <span class="right">Left</span>
</div>
```

## Method #7: Justify-content: Space-between & Invisible Flex Item (DOM element)

```
.parent {
  align-items: center;
  border: 1px solid black;
  display: flex;
  justify-content: space-between;
  margin: 0 auto;
  width: 500px;
}

<div class="parent">
  <span class="left">Left</span>
  <span class="center">Center</span>
  <span class="right"></span>
</div>
```


