# HTTP

OSI: 应用层（HTTP）、表示层、会话层（TLS、SSH）、传输层（TCP、UDP）、网络（IP）、链路传输层（以太网）、物理层

---

HTTP 超文本传输协议，是用于传输诸如HTML的媒体文件的应用层协议。

HTTP遵循经典的 [客户端-服务端模型](https://en.wikipedia.org/wiki/Client%E2%80%93server_model) ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。

HTTP是 [无状态协议](http://en.wikipedia.org/wiki/Stateless_protocol) ，意味着服务器不会在两个请求之间保留任何数据（状态）。虽然通常基于TCP / IP层，但可以在任何可靠的 [传输层](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82) 上使用; 也就是说，一个不会静默丢失消息的协议，如UDP。

客户端与服务端之间：代理，代理主要有如下几种作用：

* 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
* 过滤（像反病毒扫描，家长控制…）
* 负载均衡（让多个服务器服务不同的请求）
* 认证（对不同资源进行权限管理）
* 日志记录（允许存储历史信息）

## HTTP的本质
HTTP本质是无状态的，使用Cookies可以创建有状态的会话。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。

## HTTP请求
HTTP 请求由三部分构成，分别为：

* 请求行
* 首部
* 实体

请求行大概长这样GET /images/logo.gif HTTP/1.1，基本由请求方法、URL、协议版本组成.

Q：POST GET的区别

* Get 请求能缓存，Post 不能
* Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里（当然你想写到body里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
* URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
* Post 支持更多的编码类型且不对数据类型限制

（我觉得本质上都一样，只不过GET相对于更加用于拉取数据，而POST更多用于发送数据

#### 首部

分为请求首部和响应首部，并且部分首部两种通用

## HTTP状态码
*2开头 （请求成功）表示成功处理了请求的状态代码。*
* 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
* 201 （已创建） 请求成功并且服务器创建了新的资源。
* 202 （已接受） 服务器已接受请求，但尚未处理。
* 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
* 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
* 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
* 206 （部分内容） 服务器成功处理了部分 GET 请求。
*3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。*
* 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
* 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
* 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
* 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
* 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
* 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
* 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
*4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。*
* 400 （错误请求） 服务器不理解请求的语法。
* 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
* 403 （禁止） 服务器拒绝请求。
* 404 （未找到） 服务器找不到请求的网页。
* 405 （方法禁用） 禁用请求中指定的方法。
* 406 （不接受） 无法使用请求的内容特性响应请求的网页。
* 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
* 408 （请求超时） 服务器等候请求时发生超时。
* 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
* 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
* 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
* 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
* 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
* 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
* 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
* 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
* 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。
*5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。*
* 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
* 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
* 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
* 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
* 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
* 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

## UDP 与 TCP 的区别是什么
1. UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。
2. 不可靠性：收到什么数据就传递什么数据，并且也不会备份数据，网络条件不好的情况下可能会导致丢包
3. 高效：UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。
4. 广播和多播仅应用于UDP
适用于直播

## HTTP2.0的特性
主要基于SPDY协议。SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。

HTTP/2.0 相比1.0有哪些重大改进？ - Leo Zhang的回答 - 知乎
https://www.zhihu.com/question/34074946/answer/75364178

1. 二进制分帧：在二进制分帧层中， HTTP/2 会将所有传输的消息分割为更小的帧，并采用二进制的编码。其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的*关键并不在于高带宽*，而是*低延迟*。HTTP/2 通过让所有数据流共用同一个连接，可以更高效的使用TCP连接。
2. 压缩头部：HTTP 2.0在客户端和服务端使用*首部表*来跟踪和存储之间发送的键-值对，对相同请求而言不需要再次发送请求和相应发送，通信期间几乎不会改变的通用键值,如user-Agent和content-Type值发送一次，相当于做了一层缓存。
3. 多路复用：HTTP 1.1而言，浏览器通常有并行连接的限制，即最多几个并行链接。而多路复用允许通过单一的HTTP 2.0连接发起多重的请求-相应消息
这意味着HTTP 2.0的通信都在一个连接上完成了，这个连接可以承载任意数量的双向数据流，直观来说，就是上面我们所做的优化已经不需要了。
4. # 请求优先级所有资源可以并行交错发送， 那想要优先拿到CSS和JS而不是图片怎么办，在每个HTTP 2.0的流里面有个优先值，这个优先值确定着客户端跟服务器处理不同的流采取不同的优先级策略，高优先级优先发送，但这不是绝对的(绝对等待会导致首队阻塞问题)
5. # 服务器提示HTTP 2.0新增加服务器提示，可以先于客户端检测到将要请求的资源，提前通知客户端，服务器不发送所有资源的实体，只发送资源的URL，客户端接到提示后会进行验证缓存，如果真需要这些资源，则正式发起请求（服务器主动更新静态资源）

- HTTP2.0 对前端优化带来的影响：* 因为“所有的 HTTP2.0 的请求都在一个 TCP 链接上”，“资源合并减少请求”，比如 CSS Sprites，多个 JS 文件、CSS 文件合并等手段没有效果，或者说没有必要。
* 因为“多路复用”，采用“cdn1.cn，cdn2.cn，cdn3.cn，打开多个 TCP 会话，突破浏览器对同一域名的链接数的限制”的手段是没有必要的。因为因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载。
* 因为“服务器推送”，内嵌资源的优化手段也变得没有意义了。而且使用服务器推送的资源的方式更加高效，因为客户端还可以缓存起来，甚至可以由不同的页面共享（依旧遵循同源策略）。

[HTTP2.0 的总结 - 不忘初心，上下求索。](https://liyaoli.com/2015-04-18/HTTP-2.0.html)

https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc729af265da615a414603
## TCP/IP 与 HTTP协议的区别
*TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据*
> 我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上

## sokect
[TCP/IP、Http、Socket的区别? - 知乎](https://www.zhihu.com/question/39541968)

## websokect
Websocket相对与HTTP协议来说是一个持久化的协议。
可以看到HTTP获取数据的时候，需要不断的问服务端是否有我要的数据啊，如果有数据就返回数据，没有就过一段时间再次询问服务端是否有我需要的数据。那websocket呢，它只建立一次连接，那么这个连接就不会断，服务端如果有数据的话，会自动返回数据给客户端，还有一个问题，在HTTP中我们提到，HTTP是无状态的，意思它健忘，上一次的请求和这次的请求都没什么联系，我们需要引用cookie才能解决。那么在websockt中，因为是一次长连接，那么这就不用一次次加入cookie，是不是方便很多了。 下面的代码就是websocket在前端代码中的应用
[前端面试之websocket篇 - 简书](https://www.jianshu.com/p/2bace419003f)
## service worker


[image:(null)/(null)][image:(null)/(null)][image:(null)/(null)]